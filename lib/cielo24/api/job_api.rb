=begin
#Cielo24

#The cielo24 Web Services Platform API allows developers to easily integrate transcription, captioning and keyword extraction into their applications without having to use a manual web portal.

The version of the OpenAPI document: 1.0.0
Contact: devs@cielo24.com
Generated by: https://openapi-generator.tech
OpenAPI Generator version: 6.0.0

=end

require 'cgi'

module cielo24
  class JobApi
    attr_accessor :api_client

    def initialize(api_client = ApiClient.default)
      @api_client = api_client
    end
    # Add a piece of media to an existing job using a local file. No content-type should be included in the HTTP header. The media should be uploaded as raw binary, no encoding (base64, hex, etc) is required. Chunk-transfer encoding is NOT supported. File size is limited to 10 gb
    # @param v [Integer] 
    # @param job_id [String] 
    # @param content_length [Integer] 
    # @param body [File] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :is_duplicate  (default to 'false')
    # @return [AddMediaResponse]
    def add_media_file(v, job_id, content_length, body, opts = {})
      data, _status_code, _headers = add_media_file_with_http_info(v, job_id, content_length, body, opts)
      data
    end

    # Add a piece of media to an existing job using a local file. No content-type should be included in the HTTP header. The media should be uploaded as raw binary, no encoding (base64, hex, etc) is required. Chunk-transfer encoding is NOT supported. File size is limited to 10 gb
    # @param v [Integer] 
    # @param job_id [String] 
    # @param content_length [Integer] 
    # @param body [File] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :is_duplicate  (default to 'false')
    # @return [Array<(AddMediaResponse, Integer, Hash)>] AddMediaResponse data, response status code and response headers
    def add_media_file_with_http_info(v, job_id, content_length, body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.add_media_file ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.add_media_file"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling JobApi.add_media_file"
      end
      # verify the required parameter 'content_length' is set
      if @api_client.config.client_side_validation && content_length.nil?
        fail ArgumentError, "Missing the required parameter 'content_length' when calling JobApi.add_media_file"
      end
      if @api_client.config.client_side_validation && content_length > 10737418239
        fail ArgumentError, 'invalid value for "content_length" when calling JobApi.add_media_file, must be smaller than or equal to 10737418239.'
      end

      # verify the required parameter 'body' is set
      if @api_client.config.client_side_validation && body.nil?
        fail ArgumentError, "Missing the required parameter 'body' when calling JobApi.add_media_file"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'is_duplicate'] && !allowable_values.include?(opts[:'is_duplicate'])
        fail ArgumentError, "invalid value for \"is_duplicate\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/job/add_media'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'job_id'] = job_id
      query_params[:'is_duplicate'] = opts[:'is_duplicate'] if !opts[:'is_duplicate'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['video/mp4'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end
      header_params[:'Content-Length'] = content_length

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(body)

      # return_type
      return_type = opts[:debug_return_type] || 'AddMediaResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.add_media_file",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#add_media_file\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Add a piece of media to an existing job using a public media url. A job may only have a single piece of media associated with it, attempting to add additional media will return an error code.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param media_url [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :is_duplicate  (default to 'false')
    # @return [AddMediaResponse]
    def add_media_url(v, job_id, media_url, opts = {})
      data, _status_code, _headers = add_media_url_with_http_info(v, job_id, media_url, opts)
      data
    end

    # Add a piece of media to an existing job using a public media url. A job may only have a single piece of media associated with it, attempting to add additional media will return an error code.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param media_url [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :is_duplicate  (default to 'false')
    # @return [Array<(AddMediaResponse, Integer, Hash)>] AddMediaResponse data, response status code and response headers
    def add_media_url_with_http_info(v, job_id, media_url, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.add_media_url ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.add_media_url"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling JobApi.add_media_url"
      end
      # verify the required parameter 'media_url' is set
      if @api_client.config.client_side_validation && media_url.nil?
        fail ArgumentError, "Missing the required parameter 'media_url' when calling JobApi.add_media_url"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'is_duplicate'] && !allowable_values.include?(opts[:'is_duplicate'])
        fail ArgumentError, "invalid value for \"is_duplicate\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/job/add_media'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'job_id'] = job_id
      query_params[:'media_url'] = media_url
      query_params[:'is_duplicate'] = opts[:'is_duplicate'] if !opts[:'is_duplicate'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'AddMediaResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.add_media_url",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#add_media_url\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Authorize an existing job. If your account has the \"customer authorization\" feature enabled (it is not enabled by default) jobs you create will be held in the \"Authorizing\" state until you call this method. Calling this method on a job that is not the \"Authorizing\" state has no effect and will return success. Please contact support@cielo24.com to enable the \"customer authorization\" feature.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [nil]
    def authorize_job(v, job_id, opts = {})
      authorize_job_with_http_info(v, job_id, opts)
      nil
    end

    # Authorize an existing job. If your account has the \&quot;customer authorization\&quot; feature enabled (it is not enabled by default) jobs you create will be held in the \&quot;Authorizing\&quot; state until you call this method. Calling this method on a job that is not the \&quot;Authorizing\&quot; state has no effect and will return success. Please contact support@cielo24.com to enable the \&quot;customer authorization\&quot; feature.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(nil, Integer, Hash)>] nil, response status code and response headers
    def authorize_job_with_http_info(v, job_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.authorize_job ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.authorize_job"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling JobApi.authorize_job"
      end
      # resource path
      local_var_path = '/job/authorize'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'job_id'] = job_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type]

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.authorize_job",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#authorize_job\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Get the caption file for a job. The job must have completed transcription before a caption can be downloaded.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param caption_format [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :build_url Rather than returning the file, return a permanent URL to the file. (default to 'false')
    # @option opts [Integer] :caption_words_min Minimum number of words allowed in a caption. (default to 1)
    # @option opts [String] :caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (default to 'true')
    # @option opts [Integer] :characters_per_caption_line Maximum number of characters to be displayed on each caption line. (default to 42)
    # @option opts [String] :dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (default to '')
    # @option opts [String] :disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (default to 'false')
    # @option opts [String] :display_effects_speaker_as Determines what speaker name should used for sound effects. (default to 'Effects')
    # @option opts [String] :display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (default to 'name')
    # @option opts [String] :iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (default to '')
    # @option opts [String] :elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (default to '')
    # @option opts [String] :emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (default to '>>')
    # @option opts [String] :force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (default to '')
    # @option opts [String] :include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (default to 'true')
    # @option opts [Integer] :layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (default to 5000)
    # @option opts [String] :line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (default to 'false')
    # @option opts [String] :line_ending_format Determine the end of line (EOL) character to use for the captions. (default to 'UNIX')
    # @option opts [Integer] :lines_per_caption Number of lines to be displayed for each caption. (default to 2)
    # @option opts [String] :mask_profanity Replace profanity with asterisks. (default to 'false')
    # @option opts [Integer] :maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum.
    # @option opts [Integer] :merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (default to 1000)
    # @option opts [Integer] :minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time.
    # @option opts [Integer] :minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap.
    # @option opts [String] :qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (default to 'false')
    # @option opts [String] :remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (default to 'true')
    # @option opts [Array<String>] :remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true.
    # @option opts [String] :remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (default to 'true')
    # @option opts [String] :replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (default to 'false')
    # @option opts [Integer] :silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (default to 2000)
    # @option opts [String] :single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (default to 'true')
    # @option opts [Array<String>] :sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC].
    # @option opts [Integer] :sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound.
    # @option opts [String] :sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (default to 'false')
    # @option opts [String] :sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (default to 'false')
    # @option opts [Array<String>] :sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true.
    # @option opts [Array<String>] :sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true.
    # @option opts [String] :speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (default to 'true')
    # @option opts [String] :srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request.  (default to '{caption_number:d}\\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\\n{caption_text}\\n\\n')
    # @option opts [String] :strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (default to 'false')
    # @option opts [String] :utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (default to 'false')
    # @option opts [String] :replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian  (default to 'A')
    # @return [String]
    def get_caption(v, job_id, caption_format, opts = {})
      data, _status_code, _headers = get_caption_with_http_info(v, job_id, caption_format, opts)
      data
    end

    # Get the caption file for a job. The job must have completed transcription before a caption can be downloaded.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param caption_format [String] 
    # @param [Hash] opts the optional parameters
    # @option opts [String] :build_url Rather than returning the file, return a permanent URL to the file. (default to 'false')
    # @option opts [Integer] :caption_words_min Minimum number of words allowed in a caption. (default to 1)
    # @option opts [String] :caption_by_sentence When true, puts each sentence into its own caption. When false, more than one sentence may appear in a single caption. (default to 'true')
    # @option opts [Integer] :characters_per_caption_line Maximum number of characters to be displayed on each caption line. (default to 42)
    # @option opts [String] :dfxp_header Allows you to specify a custom header for your DFXP caption file. The header should be the entire contents of the header including the opening and closing tags. Ignored if caption_format does not equal DFXP. (default to '')
    # @option opts [String] :disallow_dangling Will prevent captions from having the last word in a sentence start a new line. Last words will ALWAYS be kept on the same line, even if it breaks the characters_per_caption_line option. (default to 'false')
    # @option opts [String] :display_effects_speaker_as Determines what speaker name should used for sound effects. (default to 'Effects')
    # @option opts [String] :display_speaker_id Determines the way speakers are identified in the captions. Choose \&quot;no\&quot; to not display speaker identities at all: \&quot;&gt;&gt; example\&quot; Choose \&quot;number\&quot; to display only the speaker number: \&quot;&gt;&gt; Speaker 1: example\&quot; Choose \&quot;name\&quot; to display the speaker name: \&quot;&gt;&gt; John Doe: example\&quot;. If you choose \&quot;name\&quot;, the speaker number will be displayed if the name is not available. (default to 'name')
    # @option opts [String] :iwp_name The named version of element list to generate the transcript from. If not specified, the transcript will be generated from the latest version. (default to '')
    # @option opts [String] :elementlist_version The version of element list to generate the captions from. If not specified, the caption will be generated from the latest version. (ISO 8601 Date String) (default to '')
    # @option opts [String] :emit_speaker_change_tokens_as Determine what characters to use to denote speaker changes. (default to '>>')
    # @option opts [String] :force_case Force the contents of the captions to be all UPPER or lower case. If blank, the case of the captions is not changed. (default to '')
    # @option opts [String] :include_dfxp_metadata When true, and the caption format requested is DFXP, the jobs name, ID and language will be added to the DFXP metadata header. When false, these data are omitted from the header. Ignored if caption_format does not equal DFXP. (default to 'true')
    # @option opts [Integer] :layout_target_caption_length_ms Captions generated will, on average, be this duration. However, they may vary significantly based on other parameters you set. (default to 5000)
    # @option opts [String] :line_break_on_sentence Inserts a line break in between sentences that are in the same caption. (default to 'false')
    # @option opts [String] :line_ending_format Determine the end of line (EOL) character to use for the captions. (default to 'UNIX')
    # @option opts [Integer] :lines_per_caption Number of lines to be displayed for each caption. (default to 2)
    # @option opts [String] :mask_profanity Replace profanity with asterisks. (default to 'false')
    # @option opts [Integer] :maximum_caption_duration No captions longer than this (in milliseconds) will be produced. If not specified, there is no maximum.
    # @option opts [Integer] :merge_gap_interval Captions with a gap between them that is smaller than this (in milliseconds) will have their start and/or end times changed so there is no time gap between the captions. (default to 1000)
    # @option opts [Integer] :minimum_caption_length_ms Extends the duration of short captions to the this minimum length. Additional time is taken from later caption blocks to meet this minimum time.
    # @option opts [Integer] :minimum_gap_between_captions_ms Adds a minimum time between captions such as there will always be some time between captions where no text is displayed. When captions are very close together, time will be removed from the caption duration to make the gap.
    # @option opts [String] :qt_seamless Does not put time gaps of any kind between caption blocks. Ignored if caption_format does not equal QT. (default to 'false')
    # @option opts [String] :remove_disfluencies Remove verbal disfluencies from the generated transcript. Common disfluencies such as \&quot;um\&quot; and \&quot;ah\&quot; are removed while maintaining appropriate punctuation. (default to 'true')
    # @option opts [Array<String>] :remove_sounds_list A list of sounds to not show in the caption. This is a JSON style list, and should look like [\&quot;MUSIC\&quot;, \&quot;LAUGH\&quot;]. Ignored if remove_sound_references is true.
    # @option opts [String] :remove_sound_references Remove ALL non-verbal sound and noise references from the generated transcript. Sounds and unidentified noises are depicted in the caption as [SOUND], [COUGH] and [NOISE]. If this parameter is set, these identifiers are omitted from the caption. (default to 'true')
    # @option opts [String] :replace_slang Replace common slang terms from the generated transcript. Common replacements are \&quot;want to\&quot; for \&quot;wanna\&quot;, \&quot;going to\&quot; for \&quot;gonna\&quot;, etc. (default to 'false')
    # @option opts [Integer] :silence_max_ms If there is a interval of silence in the middle of a sentence longer than this, then the caption will be split. (default to 2000)
    # @option opts [String] :single_speaker_per_caption When true, puts each speaker into its own caption. When false, more than one speaker may appear in a single caption. (default to 'true')
    # @option opts [Array<String>] :sound_boundaries Specifies the characters to surround sound references with. The default will generate sound references that look like this: [MUSIC].
    # @option opts [Integer] :sound_threshold Sound references that are longer than this threshold will be made their own caption entirely, and will not have any text included with them. If not set, Sound references will be included back to back with text no matter the duration of the sound.
    # @option opts [String] :sound_tokens_by_caption If true, all sound references will always be in their own caption. If false, more than one sound reference may appear in a single caption. (default to 'false')
    # @option opts [String] :sound_tokens_by_line If true, all sound references will always be in their own line. If false, more than one sound reference may appear in a single line. (default to 'false')
    # @option opts [Array<String>] :sound_tokens_by_caption_list If non-empty, the specified sound references will always be in their own caption. If empty, more than one sound reference may appear in a single caption. Ignored if sound_tokens_by_caption is true.
    # @option opts [Array<String>] :sound_tokens_by_line_list If non-empty, the specified sound references will always be in their own line. If empty, more than one sound reference may appear in a single line. Ignored if sound_tokens_by_line is true.
    # @option opts [String] :speaker_on_new_line If true, a speaker change will cause a new caption to be made. If false, multiple speakers may appear in a single caption. (default to 'true')
    # @option opts [String] :srt_format If the caption format is SRT, determines what the caption blocks will look like. The default, prints caption blocks that look like this:    1:   00:00:06,060 --&gt; 00:00:16,060   This is the caption text.  You can alter the caption block by re-arranging or removing the substitution string values, shown enclosed in braces \&quot;{}\&quot; in the default value below. Substitution strings may used more than once if desired. Any text that is not a substitution string will be displayed as written. To add new lines, include a \\n. Note, you may need to escape the \\n with an extra backslash when encoding the request.  (default to '{caption_number:d}\\n{start_hour:02d}:{start_minute:02d}:{start_second:02d},{start_millisecond:03d} -->{end_hour:02d}:{end_minute:02d}:{end_second:02d},{end_millisecond:03d}\\n{caption_text}\\n\\n')
    # @option opts [String] :strip_square_brackets Removes all square brackets like &#39;[&#39; or &#39;]&#39; from captions. By default square brackets surround sound references like &#39;[MUSIC]&#39;, but they may exist as part of the caption text as well. (default to 'false')
    # @option opts [String] :utf8_mark Adds a utf8 bytemark to the beginning of the caption. This should only be used if the system you are loading the caption files into needs a byte marker. The vast majority of systems do not. (default to 'false')
    # @option opts [String] :replace_english_spelling Replaces English spelling with location accurate spelling. i.e. Color --&gt; Colour  A: American  B: British  Z: British ize  U: Australian  C: Canadian  (default to 'A')
    # @return [Array<(String, Integer, Hash)>] String data, response status code and response headers
    def get_caption_with_http_info(v, job_id, caption_format, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.get_caption ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.get_caption"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling JobApi.get_caption"
      end
      # verify the required parameter 'caption_format' is set
      if @api_client.config.client_side_validation && caption_format.nil?
        fail ArgumentError, "Missing the required parameter 'caption_format' when calling JobApi.get_caption"
      end
      # verify enum value
      allowable_values = ["DFXP", "ECHO", "QT", "SAMI", "SBV", "SCC", "SRT", "TPM", "TRANSCRIPT", "TWX", "WEB_VTT"]
      if @api_client.config.client_side_validation && !allowable_values.include?(caption_format)
        fail ArgumentError, "invalid value for \"caption_format\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'build_url'] && !allowable_values.include?(opts[:'build_url'])
        fail ArgumentError, "invalid value for \"build_url\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'caption_by_sentence'] && !allowable_values.include?(opts[:'caption_by_sentence'])
        fail ArgumentError, "invalid value for \"caption_by_sentence\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'disallow_dangling'] && !allowable_values.include?(opts[:'disallow_dangling'])
        fail ArgumentError, "invalid value for \"disallow_dangling\", must be one of #{allowable_values}"
      end
      allowable_values = ["no", "number", "name"]
      if @api_client.config.client_side_validation && opts[:'display_speaker_id'] && !allowable_values.include?(opts[:'display_speaker_id'])
        fail ArgumentError, "invalid value for \"display_speaker_id\", must be one of #{allowable_values}"
      end
      allowable_values = ["PREMIUM", "INTERIM_PROFESSIONAL", "PROFESSIONAL", "SPEAKER_ID", "FINAL", "MECHANICAL", "CUSTOMER_APPROVED_RETURN", "CUSTOMER_APPROVED_TRANSLATION"]
      if @api_client.config.client_side_validation && opts[:'iwp_name'] && !allowable_values.include?(opts[:'iwp_name'])
        fail ArgumentError, "invalid value for \"iwp_name\", must be one of #{allowable_values}"
      end
      allowable_values = ["", "lower", "upper"]
      if @api_client.config.client_side_validation && opts[:'force_case'] && !allowable_values.include?(opts[:'force_case'])
        fail ArgumentError, "invalid value for \"force_case\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'include_dfxp_metadata'] && !allowable_values.include?(opts[:'include_dfxp_metadata'])
        fail ArgumentError, "invalid value for \"include_dfxp_metadata\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'line_break_on_sentence'] && !allowable_values.include?(opts[:'line_break_on_sentence'])
        fail ArgumentError, "invalid value for \"line_break_on_sentence\", must be one of #{allowable_values}"
      end
      allowable_values = ["UNIX", "OSX", "WINDOWS"]
      if @api_client.config.client_side_validation && opts[:'line_ending_format'] && !allowable_values.include?(opts[:'line_ending_format'])
        fail ArgumentError, "invalid value for \"line_ending_format\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'mask_profanity'] && !allowable_values.include?(opts[:'mask_profanity'])
        fail ArgumentError, "invalid value for \"mask_profanity\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'qt_seamless'] && !allowable_values.include?(opts[:'qt_seamless'])
        fail ArgumentError, "invalid value for \"qt_seamless\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'remove_disfluencies'] && !allowable_values.include?(opts[:'remove_disfluencies'])
        fail ArgumentError, "invalid value for \"remove_disfluencies\", must be one of #{allowable_values}"
      end
      allowable_values = ["UNKNOWN", "INAUDIBLE", "CROSSTALK", "MUSIC", "NOISE", "LAUGH", "COUGH", "FOREIGN", "BLANK_AUDIO", "APPLAUSE", "BLEEP", "ENDS_SENTENCE"]
      if @api_client.config.client_side_validation && opts[:'remove_sounds_list'] && !opts[:'remove_sounds_list'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"remove_sounds_list\", must include one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'remove_sound_references'] && !allowable_values.include?(opts[:'remove_sound_references'])
        fail ArgumentError, "invalid value for \"remove_sound_references\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'replace_slang'] && !allowable_values.include?(opts[:'replace_slang'])
        fail ArgumentError, "invalid value for \"replace_slang\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'single_speaker_per_caption'] && !allowable_values.include?(opts[:'single_speaker_per_caption'])
        fail ArgumentError, "invalid value for \"single_speaker_per_caption\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'sound_tokens_by_caption'] && !allowable_values.include?(opts[:'sound_tokens_by_caption'])
        fail ArgumentError, "invalid value for \"sound_tokens_by_caption\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'sound_tokens_by_line'] && !allowable_values.include?(opts[:'sound_tokens_by_line'])
        fail ArgumentError, "invalid value for \"sound_tokens_by_line\", must be one of #{allowable_values}"
      end
      allowable_values = ["UNKNOWN", "INAUDIBLE", "CROSSTALK", "MUSIC", "NOISE", "LAUGH", "COUGH", "FOREIGN", "BLANK_AUDIO", "APPLAUSE", "BLEEP", "ENDS_SENTENCE"]
      if @api_client.config.client_side_validation && opts[:'sound_tokens_by_caption_list'] && !opts[:'sound_tokens_by_caption_list'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"sound_tokens_by_caption_list\", must include one of #{allowable_values}"
      end
      allowable_values = ["UNKNOWN", "INAUDIBLE", "CROSSTALK", "MUSIC", "NOISE", "LAUGH", "COUGH", "FOREIGN", "BLANK_AUDIO", "APPLAUSE", "BLEEP", "ENDS_SENTENCE"]
      if @api_client.config.client_side_validation && opts[:'sound_tokens_by_line_list'] && !opts[:'sound_tokens_by_line_list'].all? { |item| allowable_values.include?(item) }
        fail ArgumentError, "invalid value for \"sound_tokens_by_line_list\", must include one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'speaker_on_new_line'] && !allowable_values.include?(opts[:'speaker_on_new_line'])
        fail ArgumentError, "invalid value for \"speaker_on_new_line\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'strip_square_brackets'] && !allowable_values.include?(opts[:'strip_square_brackets'])
        fail ArgumentError, "invalid value for \"strip_square_brackets\", must be one of #{allowable_values}"
      end
      allowable_values = ["true", "false"]
      if @api_client.config.client_side_validation && opts[:'utf8_mark'] && !allowable_values.include?(opts[:'utf8_mark'])
        fail ArgumentError, "invalid value for \"utf8_mark\", must be one of #{allowable_values}"
      end
      allowable_values = ["A", "B", "Z", "U", "C"]
      if @api_client.config.client_side_validation && opts[:'replace_english_spelling'] && !allowable_values.include?(opts[:'replace_english_spelling'])
        fail ArgumentError, "invalid value for \"replace_english_spelling\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/job/get_caption'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'job_id'] = job_id
      query_params[:'caption_format'] = caption_format
      query_params[:'build_url'] = opts[:'build_url'] if !opts[:'build_url'].nil?
      query_params[:'caption_words_min'] = opts[:'caption_words_min'] if !opts[:'caption_words_min'].nil?
      query_params[:'caption_by_sentence'] = opts[:'caption_by_sentence'] if !opts[:'caption_by_sentence'].nil?
      query_params[:'characters_per_caption_line'] = opts[:'characters_per_caption_line'] if !opts[:'characters_per_caption_line'].nil?
      query_params[:'dfxp_header'] = opts[:'dfxp_header'] if !opts[:'dfxp_header'].nil?
      query_params[:'disallow_dangling'] = opts[:'disallow_dangling'] if !opts[:'disallow_dangling'].nil?
      query_params[:'display_effects_speaker_as'] = opts[:'display_effects_speaker_as'] if !opts[:'display_effects_speaker_as'].nil?
      query_params[:'display_speaker_id'] = opts[:'display_speaker_id'] if !opts[:'display_speaker_id'].nil?
      query_params[:'iwp_name'] = opts[:'iwp_name'] if !opts[:'iwp_name'].nil?
      query_params[:'elementlist_version'] = opts[:'elementlist_version'] if !opts[:'elementlist_version'].nil?
      query_params[:'emit_speaker_change_tokens_as'] = opts[:'emit_speaker_change_tokens_as'] if !opts[:'emit_speaker_change_tokens_as'].nil?
      query_params[:'force_case'] = opts[:'force_case'] if !opts[:'force_case'].nil?
      query_params[:'include_dfxp_metadata'] = opts[:'include_dfxp_metadata'] if !opts[:'include_dfxp_metadata'].nil?
      query_params[:'layout_target_caption_length_ms'] = opts[:'layout_target_caption_length_ms'] if !opts[:'layout_target_caption_length_ms'].nil?
      query_params[:'line_break_on_sentence'] = opts[:'line_break_on_sentence'] if !opts[:'line_break_on_sentence'].nil?
      query_params[:'line_ending_format'] = opts[:'line_ending_format'] if !opts[:'line_ending_format'].nil?
      query_params[:'lines_per_caption'] = opts[:'lines_per_caption'] if !opts[:'lines_per_caption'].nil?
      query_params[:'mask_profanity'] = opts[:'mask_profanity'] if !opts[:'mask_profanity'].nil?
      query_params[:'maximum_caption_duration'] = opts[:'maximum_caption_duration'] if !opts[:'maximum_caption_duration'].nil?
      query_params[:'merge_gap_interval'] = opts[:'merge_gap_interval'] if !opts[:'merge_gap_interval'].nil?
      query_params[:'minimum_caption_length_ms'] = opts[:'minimum_caption_length_ms'] if !opts[:'minimum_caption_length_ms'].nil?
      query_params[:'minimum_gap_between_captions_ms'] = opts[:'minimum_gap_between_captions_ms'] if !opts[:'minimum_gap_between_captions_ms'].nil?
      query_params[:'qt_seamless'] = opts[:'qt_seamless'] if !opts[:'qt_seamless'].nil?
      query_params[:'remove_disfluencies'] = opts[:'remove_disfluencies'] if !opts[:'remove_disfluencies'].nil?
      query_params[:'remove_sounds_list'] = @api_client.build_collection_param(opts[:'remove_sounds_list'], :multi) if !opts[:'remove_sounds_list'].nil?
      query_params[:'remove_sound_references'] = opts[:'remove_sound_references'] if !opts[:'remove_sound_references'].nil?
      query_params[:'replace_slang'] = opts[:'replace_slang'] if !opts[:'replace_slang'].nil?
      query_params[:'silence_max_ms'] = opts[:'silence_max_ms'] if !opts[:'silence_max_ms'].nil?
      query_params[:'single_speaker_per_caption'] = opts[:'single_speaker_per_caption'] if !opts[:'single_speaker_per_caption'].nil?
      query_params[:'sound_boundaries'] = @api_client.build_collection_param(opts[:'sound_boundaries'], :multi) if !opts[:'sound_boundaries'].nil?
      query_params[:'sound_threshold'] = opts[:'sound_threshold'] if !opts[:'sound_threshold'].nil?
      query_params[:'sound_tokens_by_caption'] = opts[:'sound_tokens_by_caption'] if !opts[:'sound_tokens_by_caption'].nil?
      query_params[:'sound_tokens_by_line'] = opts[:'sound_tokens_by_line'] if !opts[:'sound_tokens_by_line'].nil?
      query_params[:'sound_tokens_by_caption_list'] = @api_client.build_collection_param(opts[:'sound_tokens_by_caption_list'], :multi) if !opts[:'sound_tokens_by_caption_list'].nil?
      query_params[:'sound_tokens_by_line_list'] = @api_client.build_collection_param(opts[:'sound_tokens_by_line_list'], :multi) if !opts[:'sound_tokens_by_line_list'].nil?
      query_params[:'speaker_on_new_line'] = opts[:'speaker_on_new_line'] if !opts[:'speaker_on_new_line'].nil?
      query_params[:'srt_format'] = opts[:'srt_format'] if !opts[:'srt_format'].nil?
      query_params[:'strip_square_brackets'] = opts[:'strip_square_brackets'] if !opts[:'strip_square_brackets'].nil?
      query_params[:'utf8_mark'] = opts[:'utf8_mark'] if !opts[:'utf8_mark'].nil?
      query_params[:'replace_english_spelling'] = opts[:'replace_english_spelling'] if !opts[:'replace_english_spelling'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['text/plain', 'application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'String'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.get_caption",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#get_caption\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # @param v [Integer] 
    # @param job_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [JobInfoResponse]
    def job_info(v, job_id, opts = {})
      data, _status_code, _headers = job_info_with_http_info(v, job_id, opts)
      data
    end

    # @param v [Integer] 
    # @param job_id [String] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(JobInfoResponse, Integer, Hash)>] JobInfoResponse data, response status code and response headers
    def job_info_with_http_info(v, job_id, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.job_info ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.job_info"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling JobApi.job_info"
      end
      # resource path
      local_var_path = '/job/info'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'job_id'] = job_id

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'JobInfoResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.job_info",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:GET, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#job_info\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Create a new job. A job is a container into which you can upload media and request that transcription be performed. Creating a job is prerequisite for virtually all other methods.
    # @param v [Integer] 
    # @param new_job_body [NewJobBody] 
    # @param [Hash] opts the optional parameters
    # @return [NewJobResponse]
    def new_job(v, new_job_body, opts = {})
      data, _status_code, _headers = new_job_with_http_info(v, new_job_body, opts)
      data
    end

    # Create a new job. A job is a container into which you can upload media and request that transcription be performed. Creating a job is prerequisite for virtually all other methods.
    # @param v [Integer] 
    # @param new_job_body [NewJobBody] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(NewJobResponse, Integer, Hash)>] NewJobResponse data, response status code and response headers
    def new_job_with_http_info(v, new_job_body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.new_job ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.new_job"
      end
      # verify the required parameter 'new_job_body' is set
      if @api_client.config.client_side_validation && new_job_body.nil?
        fail ArgumentError, "Missing the required parameter 'new_job_body' when calling JobApi.new_job"
      end
      # resource path
      local_var_path = '/job/new'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(new_job_body)

      # return_type
      return_type = opts[:debug_return_type] || 'NewJobResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.new_job",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#new_job\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Request that transcription be performed on the specified job. A callback URL, if specified, will be called when the transcription is complete. See [callback documentation](https://cielo24.readthedocs.io/en/latest/basics.html#callbacks-label) for details.
    # @param v [Integer] 
    # @param perform_transcription_body [PerformTranscriptionBody] 
    # @param [Hash] opts the optional parameters
    # @return [PerformTranscriptionResponse]
    def perform_transcription(v, perform_transcription_body, opts = {})
      data, _status_code, _headers = perform_transcription_with_http_info(v, perform_transcription_body, opts)
      data
    end

    # Request that transcription be performed on the specified job. A callback URL, if specified, will be called when the transcription is complete. See [callback documentation](https://cielo24.readthedocs.io/en/latest/basics.html#callbacks-label) for details.
    # @param v [Integer] 
    # @param perform_transcription_body [PerformTranscriptionBody] 
    # @param [Hash] opts the optional parameters
    # @return [Array<(PerformTranscriptionResponse, Integer, Hash)>] PerformTranscriptionResponse data, response status code and response headers
    def perform_transcription_with_http_info(v, perform_transcription_body, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.perform_transcription ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.perform_transcription"
      end
      # verify the required parameter 'perform_transcription_body' is set
      if @api_client.config.client_side_validation && perform_transcription_body.nil?
        fail ArgumentError, "Missing the required parameter 'perform_transcription_body' when calling JobApi.perform_transcription"
      end
      # resource path
      local_var_path = '/job/perform_transcription'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])
      # HTTP header 'Content-Type'
      content_type = @api_client.select_header_content_type(['application/json'])
      if !content_type.nil?
          header_params['Content-Type'] = content_type
      end

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body] || @api_client.object_to_http_body(perform_transcription_body)

      # return_type
      return_type = opts[:debug_return_type] || 'PerformTranscriptionResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.perform_transcription",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#perform_transcription\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end

    # Request that orders a new Translation language for a video that has been previously Transcribed and/or Translated. The New Job ID and job target language will be returned upon completion.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param target_languages [String] The language(s) being ordered (Any RFC 5646 language code) separated by comma (,)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :approve_uplevel 
    # @return [PerformTranslationResponse]
    def perform_translation(v, job_id, target_languages, opts = {})
      data, _status_code, _headers = perform_translation_with_http_info(v, job_id, target_languages, opts)
      data
    end

    # Request that orders a new Translation language for a video that has been previously Transcribed and/or Translated. The New Job ID and job target language will be returned upon completion.
    # @param v [Integer] 
    # @param job_id [String] 
    # @param target_languages [String] The language(s) being ordered (Any RFC 5646 language code) separated by comma (,)
    # @param [Hash] opts the optional parameters
    # @option opts [String] :approve_uplevel 
    # @return [Array<(PerformTranslationResponse, Integer, Hash)>] PerformTranslationResponse data, response status code and response headers
    def perform_translation_with_http_info(v, job_id, target_languages, opts = {})
      if @api_client.config.debugging
        @api_client.config.logger.debug 'Calling API: JobApi.perform_translation ...'
      end
      # verify the required parameter 'v' is set
      if @api_client.config.client_side_validation && v.nil?
        fail ArgumentError, "Missing the required parameter 'v' when calling JobApi.perform_translation"
      end
      # verify the required parameter 'job_id' is set
      if @api_client.config.client_side_validation && job_id.nil?
        fail ArgumentError, "Missing the required parameter 'job_id' when calling JobApi.perform_translation"
      end
      # verify the required parameter 'target_languages' is set
      if @api_client.config.client_side_validation && target_languages.nil?
        fail ArgumentError, "Missing the required parameter 'target_languages' when calling JobApi.perform_translation"
      end
      allowable_values = ["true", "false", "t", "f", "true", "false"]
      if @api_client.config.client_side_validation && opts[:'approve_uplevel'] && !allowable_values.include?(opts[:'approve_uplevel'])
        fail ArgumentError, "invalid value for \"approve_uplevel\", must be one of #{allowable_values}"
      end
      # resource path
      local_var_path = '/job/perform_translation'

      # query parameters
      query_params = opts[:query_params] || {}
      query_params[:'v'] = v
      query_params[:'job_id'] = job_id
      query_params[:'target_languages'] = target_languages
      query_params[:'approve_uplevel'] = opts[:'approve_uplevel'] if !opts[:'approve_uplevel'].nil?

      # header parameters
      header_params = opts[:header_params] || {}
      # HTTP header 'Accept' (if needed)
      header_params['Accept'] = @api_client.select_header_accept(['application/json'])

      # form parameters
      form_params = opts[:form_params] || {}

      # http body (model)
      post_body = opts[:debug_body]

      # return_type
      return_type = opts[:debug_return_type] || 'PerformTranslationResponse'

      # auth_names
      auth_names = opts[:debug_auth_names] || ['ApiKeyAuth']

      new_options = opts.merge(
        :operation => :"JobApi.perform_translation",
        :header_params => header_params,
        :query_params => query_params,
        :form_params => form_params,
        :body => post_body,
        :auth_names => auth_names,
        :return_type => return_type
      )

      data, status_code, headers = @api_client.call_api(:POST, local_var_path, new_options)
      if @api_client.config.debugging
        @api_client.config.logger.debug "API called: JobApi#perform_translation\nData: #{data.inspect}\nStatus code: #{status_code}\nHeaders: #{headers}"
      end
      return data, status_code, headers
    end
  end
end
